"""Function executor service for safely executing LLM-generated function calls."""

import json
from typing import Any, Callable, Dict, List, Optional
from src.core.exceptions import FunctionExecutionException, InvalidUseCaseException
from src.core.logging_config import get_logger
from src.domain.interfaces.function_executor import FunctionExecutor
from src.domain.interfaces.usecase_registry import UseCaseRegistry
from src.services.parser.function_parser import FunctionParser
from src.core.constants import UseCase

logger = get_logger(__name__)


class FunctionExecutorService(FunctionExecutor):
    """
    Service responsible for safely executing function calls generated by an LLM.
    It uses an AST-based parser and a function registry to control execution.
    """
    
    def __init__(self, usecase_registry: UseCaseRegistry):
        """
        Initializes the FunctionExecutorService.
        
        Args:
            usecase_registry: An instance of UseCaseRegistry to get functions for specific use cases.
        """
        self.usecase_registry = usecase_registry
        self._parsers: Dict[str, FunctionParser] = {}
        logger.info("FunctionExecutorService initialized")
    
    def execute_calls(self, function_calls: List[str], usecase: UseCase) -> str:
        """
        Parses and executes a list of function call strings for a given use case.
        
        Args:
            function_calls: A list of strings, where each string is a function call
                           (e.g., ["count_all()", "show_one(id=5)"]).
            usecase: The use case context for which the functions are to be executed.
            
        Returns:
            A newline-separated string of results from the executed functions.
            
        Raises:
            FunctionExecutionException: If any parsing or execution fails.
            InvalidUseCaseException: If the use case is not registered.
        """
        if not function_calls:
            return ""
        
        parser = self._get_parser(usecase)
        try:
            results = parser.parse_calls(function_calls)
            logger.debug(f"Successfully executed {len(function_calls)} calls for usecase {usecase.value}")
            return results
        except FunctionExecutionException as e:
            logger.error(f"Failed to execute function calls for usecase {usecase.value}: {e}")
            raise
        except Exception as e:
            logger.error(f"An unexpected error occurred during function execution: {e}")
            raise FunctionExecutionException(f"An unexpected error occurred during function execution: {e}")
    
    def get_available_functions(self, usecase: UseCase) -> Dict[str, Callable]:
        """
        Retrieves all registered functions for a specific use case.
        
        Args:
            usecase: The name of the use case.
            
        Returns:
            A dictionary of callable functions.
            
        Raises:
            InvalidUseCaseException: If the use case is not found.
        """
        try:
            return self.usecase_registry.get_functions(usecase)
        except FunctionExecutionException as e:
            raise InvalidUseCaseException(f"Usecase '{usecase.value}' not found: {e}")
    
    def validate_function_call(self, function_call_str: str, usecase: UseCase) -> bool:
        """
        Validates if a given function call string is syntactically correct
        and refers to a registered function for the specified use case.
        
        Args:
            function_call_str: The string representation of the function call.
            usecase: The use case context.
            
        Returns:
            True if the function call is valid, False otherwise.
        """
        try:
            parser = self._get_parser(usecase)
            parsed_call = parser._ast_parser.parse_function_call(function_call_str)
            func_name = parsed_call["name"]
            self.usecase_registry.get_function(usecase, func_name)  # Check if function exists
            return True
        except (FunctionExecutionException, InvalidUseCaseException):
            return False
    
    def get_parser_stats(self) -> Dict[str, Any]:
        """
        Get statistics about the function executor service.
        """
        return {
            "num_parsers_cached": len(self._parsers),
            "cached_usecases": list(self._parsers.keys())
        }
    
    def _get_parser(self, usecase: UseCase) -> FunctionParser:
        """
        Retrieves or creates a FunctionParser instance for a given use case.
        """
        usecase_key = usecase.value
        
        if usecase_key not in self._parsers:
            # Get functions for this usecase
            functions = self.usecase_registry.get_functions(usecase)
            
            # Create parser with these functions
            parser = FunctionParser(functions)
            self._parsers[usecase_key] = parser
            
            logger.debug(f"Created parser for usecase: {usecase_key}")
        
        return self._parsers[usecase_key]
