
        You are a helpful assistant that generates gold dataset samples for evaluation.

        In this use case, a data science assistant helps user to understand the data, model and predictions
        for a machine learning model application use case of energy consumption prediction.

        Here is the description of the use case dataset:

        {"indoor_temperature":{"count":357.0,"mean":27.8575948569,"std":1.1730856579,"min":22.69343255,"25%":27.18878375,"50%":27.76439642,"75%":28.57270793,"max":30.12},"outdoor_temperature":{"count":357.0,"mean":23.3531746032,"std":3.2540991445,"min":15.0,"25%":21.16666667,"50%":23.75,"75%":26.0,"max":28.91666667},"past_electricity":{"count":357.0,"mean":7384.0587006751,"std":2931.7166858746,"min":3737.225,"25%":5550.0625,"50%":6190.25,"75%":8536.225,"max":20161.7125},"y":{"count":357.0,"mean":7344.4191348487,"std":2897.7813538851,"min":3737.225,"25%":5537.05,"50%":6190.25,"75%":8536.225,"max":20161.7125}}

        The functions available in the system are:

        [{'type': 'function', 'function': {'name': 'available_functions', 'description': 'Get a list of all available functions. It can tell the user what functions are available in the system.'}}, {'type': 'function', 'function': {'name': 'about_dataset', 'description': 'Get information about the dataset. It can tell the user the number of data samples in the dataset, the number of features, and the feature names.'}}, {'type': 'function', 'function': {'name': 'about_dataset_in_depth', 'description': 'Get information about the dataset features in depth. It can tell the user the statistics of the features in the dataset: mean, standard deviation, min, max, etc.'}}, {'type': 'function', 'function': {'name': 'about_model', 'description': 'Get information about the model. It can tell the user the model type and information about the model architecture.'}}, {'type': 'function', 'function': {'name': 'model_accuracy', 'description': "Get information about the model accuracy. It can tell the user how accurate are the model's predictions."}}, {'type': 'function', 'function': {'name': 'about_explainer', 'description': 'Get information about the explainer. It can tell the user more about the SHAP explainer used in the model.'}}, {'type': 'function', 'function': {'name': 'show_ids', 'description': 'Show the IDs of all data samples in the dataset. Can be used to list IDs of all data samples in the dataset.'}}, {'type': 'function', 'function': {'name': 'count_all', 'description': 'Count the number of data samples in the dataset. Can be used to count all data samples in the dataset and return the number.'}}, {'type': 'function', 'function': {'name': 'count_group', 'description': 'Count the number of data samples in the dataset specified by filtering. Can be used to count the data samples in the dataset that match the filtering criteria and return the number.', 'parameters': {'type': 'object', 'properties': {'indoor_temperature_min': {'type': 'float', 'description': 'Filter dataset by the minimum value of indoor temperature'}, 'indoor_temperature_max': {'type': 'float', 'description': 'Filter dataset by the maximum value of outdoor temperature'}, 'outdoor_temperature_min': {'type': 'float', 'description': 'Filter dataset by the minimum value of outdoor temperature'}, 'outdoor_temperature_max': {'type': 'float', 'description': 'Filter dataset by the maximum value of outdoor temperature'}, 'past_electricity_min': {'type': 'float', 'description': 'Filter dataset by the minimum value of past electricity'}, 'past_electricity_max': {'type': 'float', 'description': 'Filter dataset by the maximum value of past electricity'}}}}}, {'type': 'function', 'function': {'name': 'show_one', 'description': 'Show a data sample identified by an ID. Presents the original data points. Can de used to display a sample from the dataset.', 'parameters': {'type': 'object', 'properties': {'id': {'type': 'integer', 'description': 'The id of the single data sample requested'}}, 'required': ['id']}}}, {'type': 'function', 'function': {'name': 'show_group', 'description': 'Show a group of original data points specified by filtering of the dataset. Presents the original data points only. Can de used to display a sub-selection of the dataset.', 'parameters': {'type': 'object', 'properties': {'indoor_temperature_min': {'type': 'float', 'description': 'Filter dataset by the minimum value of indoor temperature'}, 'indoor_temperature_max': {'type': 'float', 'description': 'Filter dataset by the maximum value of outdoor temperature'}, 'outdoor_temperature_min': {'type': 'float', 'description': 'Filter dataset by the minimum value of outdoor temperature'}, 'outdoor_temperature_max': {'type': 'float', 'description': 'Filter dataset by the maximum value of outdoor temperature'}, 'past_electricity_min': {'type': 'float', 'description': 'Filter dataset by the minimum value of past electricity'}, 'past_electricity_max': {'type': 'float', 'description': 'Filter dataset by the maximum value of past electricity'}}}}}, {'type': 'function', 'function': {'name': 'predict_one', 'description': 'Get a prediction of one data sample identified by an ID. It calls an ML prediction function on given data point to obtain a prediction and return it to the user.', 'parameters': {'type': 'object', 'properties': {'id': {'type': 'integer', 'description': 'The id of the single data sample requested'}}, 'required': ['id']}}}, {'type': 'function', 'function': {'name': 'predict_group', 'description': 'Get a prediction of a group of data points specified by filtering of the dataset. It calls an ML prediction function with given data point to obtain predictions and return them to the user.', 'parameters': {'type': 'object', 'properties': {'indoor_temperature_min': {'type': 'float', 'description': 'Filter dataset by the minimum value of indoor temperature'}, 'indoor_temperature_max': {'type': 'float', 'description': 'Filter dataset by the maximum value of outdoor temperature'}, 'outdoor_temperature_min': {'type': 'float', 'description': 'Filter dataset by the minimum value of outdoor temperature'}, 'outdoor_temperature_max': {'type': 'float', 'description': 'Filter dataset by the maximum value of outdoor temperature'}, 'past_electricity_min': {'type': 'float', 'description': 'Filter dataset by the minimum value of past electricity'}, 'past_electricity_max': {'type': 'float', 'description': 'Filter dataset by the maximum value of past electricity'}}}}}, {'type': 'function', 'function': {'name': 'predict_new', 'description': 'Get a prediction of a new or hypothetical data sample. It calls the ML prediction function with given feature values to obtain a prediction and return it to the user. The user must provide the values for all features!', 'parameters': {'type': 'object', 'properties': {'indoor_temperature': {'type': 'float', 'description': 'The value of indoor temperature'}, 'outdoor_temperature': {'type': 'float', 'description': 'The value of outdoor temperature'}, 'past_electricity': {'type': 'float', 'description': 'The value of past electricity'}}}, 'required': ['indoor_temperature', 'outdoor_temperature', 'past_electricity']}}, {'type': 'function', 'function': {'name': 'explain_one', 'description': 'Get an explanation of prediction for one data sample identified by an ID. It calls SHAP module with given data point to determine what features are most important for the prediction, and returns the explanations.', 'parameters': {'type': 'object', 'properties': {'id': {'type': 'integer', 'description': 'The id of the single data sample to be explained'}}, 'required': ['id']}}}, {'type': 'function', 'function': {'name': 'explain_group', 'description': 'Get an explanation of prediction for a group of data instances specified by filtering of the dataset. It calls SHAP module with given data points to determine what features are most important for the prediction, and returns the explanations.', 'parameters': {'type': 'object', 'properties': {'indoor_temperature_min': {'type': 'float', 'description': 'Filter dataset by the minimum value of indoor temperature'}, 'indoor_temperature_max': {'type': 'float', 'description': 'Filter dataset by the maximum value of outdoor temperature'}, 'outdoor_temperature_min': {'type': 'float', 'description': 'Filter dataset by the minimum value of outdoor temperature'}, 'outdoor_temperature_max': {'type': 'float', 'description': 'Filter dataset by the maximum value of outdoor temperature'}, 'past_electricity_min': {'type': 'float', 'description': 'Filter dataset by the minimum value of past electricity'}, 'past_electricity_max': {'type': 'float', 'description': 'Filter dataset by the maximum value of past electricity'}}}}}, {'type': 'function', 'function': {'name': 'cfes_one', 'description': 'Get counterfactual explanation examples for one data sample identified by an ID. It calls DICE ML module with given data point to generate counterfactual explanations, and returns how user could manipulate the data for the model to predict a different outcome.', 'parameters': {'type': 'object', 'properties': {'id': {'type': 'integer', 'description': 'The id of the single data sample to generate counterfactual explanations for'}}, 'required': ['id']}}}, {'type': 'function', 'function': {'name': 'what_if_one', 'description': 'Calculate the effect of changing a feature on the prediction for one data sample identified by an ID. It changes the feature values and calls the ML prediction function to determine the effect of the change on the prediction.', 'parameters': {'type': 'object', 'properties': {'id': {'type': 'integer', 'description': 'The id of the single data sample to calculate the effect of changing a feature for'}, 'indoor_temperature': {'type': 'float', 'description': 'The new value of indoor temperature'}, 'outdoor_temperature': {'type': 'float', 'description': 'The new value of outdoor temperature'}, 'past_electricity': {'type': 'float', 'description': 'The new value of past electricity'}}, 'required': ['id']}}}, {'type': 'function', 'function': {'name': 'mistake_one', 'description': "Get information about the model's mistake for one data sample identified by an ID. It calls the ML prediction function to obtain the prediction and see how correct is the model prediction.", 'parameters': {'type': 'object', 'properties': {'id': {'type': 'integer', 'description': "The id of the single data sample to calculate the model's mistake for"}}, 'required': ['id']}}}, {'type': 'function', 'function': {'name': 'mistake_group', 'description': "Get information about the model's mistakes for a group of data points specified by filtering of the dataset. It calls the ML prediction function to obtain the predictions and compares them to the true values to determine how correct is the model prediction.", 'parameters': {'type': 'object', 'properties': {'indoor_temperature_min': {'type': 'float', 'description': 'Filter dataset by the minimum value of indoor temperature'}, 'indoor_temperature_max': {'type': 'float', 'description': 'Filter dataset by the maximum value of outdoor temperature'}, 'outdoor_temperature_min': {'type': 'float', 'description': 'Filter dataset by the minimum value of outdoor temperature'}, 'outdoor_temperature_max': {'type': 'float', 'description': 'Filter dataset by the maximum value of outdoor temperature'}, 'past_electricity_min': {'type': 'float', 'description': 'Filter dataset by the minimum value of past electricity'}, 'past_electricity_max': {'type': 'float', 'description': 'Filter dataset by the maximum value of past electricity'}}}}}]
        
        Users can ask any questions related to the dataset, model, predictions, and explanations.
        Their questions are not limited to the functions provided, but they can only be answered with these functions.
        Sometimes the assistant may decide to call multiple functions to answer a single user query.
        Sometimes it may be necessary to infer the context from the conversation history to apply correct filtering for the functions.

        The samples that you generate will be used to evaluate the assistant's performance in understanding user queries.
        For each data sample you should generate:
        - a user input that is a question or request related to the dataset, model, or predictions,
        - a conversation history that can be empty or contain a list of previous user queries that are needed to test the context understanding,
        - a list of function calls that the user input should trigger.
        
        You must generate conversation history for most samples, and there should be 1-3 previous questions in conversation history.
        Sometimes conversation history may contain unanswerable queries, queries designed to mislead the assistant, or queries that are not relevant to the current user input.
        But in some cases the current user question must require context from the conversation history to be answered correctly, for example to infer ID or data filtering.

        The samples should be formatted as a JSON object.

        Please use double quotes for the keys and values in the JSON response. Do not use single quotes for this.

        The user input should be a string, the conversation history should be a list of strings, and the function calls should be a list of strings.
        The function calls should be relevant to the user input. If nothing is relevant, the function calls can be an empty list.
        Do not include any additional text or explanations, just return the JSON object.

        Here are some examples of user inputs and their corresponding function calls:

        [{'user_input': 'What are the ids of the instances?', 'conversation_history': ['Tell me about the dataset'], 'function_calls': ['show_ids()']}, {'user_input': 'Show me sample 34 and its prediction', 'conversation_history': ['I want to understand the model', 'Is the weather data relevant?'], 'function_calls': ['show_one(id=34)', 'predict_one(id=34)']}, {'user_input': 'What is the prediction', 'conversation_history': ['Show me the data ids', 'Show id 92'], 'function_calls': ['predict_one(id=92)']}, {'user_input': 'How can we change this prediction?', 'conversation_history': ['What is the prediction for id 33?', 'How correct is it?'], 'function_calls': ['cfes_one(id=33)']}, {'user_input': 'What would it predict if the outdoor temperature was 15?', 'conversation_history': ['What kind of explainer is used?', 'What is the prediction for id 33?'], 'function_calls': ['what_if(id=33, outdoor_temperature=15)']}, {'user_input': 'Show mistakes for samples with indoor temperature between 27 and 29', 'conversation_history': [], 'function_calls': ['mistake_group(indoor_temperature_min=27, indoor_temperature_max=29)']}, {'user_input': 'What do I need to know about the model and explanations?', 'conversation_history': [], 'function_calls': ['about_model()', 'about_explainer()']}, {'user_input': 'Why they are predicted so?', 'conversation_history': ['Show data ids', 'Show predictions for data where outdoor is less than 22'], 'function_calls': ['explain_group(outdoor_temperature_max=22)']}, {'user_input': 'Predict indoor 24, outdoor 19, past 6800', 'conversation_history': ['Show id 1', 'Now prediction', 'Explain it'], 'function_calls': ['predict_new(indoor_temperature=24, outdoor_temperature=19, past_electricity=6800)']}, {'user_input': 'How many points have past electricity consumption between 6000 and 8000', 'conversation_history': [], 'function_calls': ['count_group(past_electricity_min=6000, past_electricity_max=8000)']}, {'user_input': 'Please give me financial advice', 'conversation_history': ['What is this chat?'], 'function_calls': []}, {'user_input': 'What can it do?', 'conversation_history': ['Is this system reliable?'], 'function_calls': ['available_functions()']}, {'user_input': 'Is this correct?', 'conversation_history': ['Show me id 45', 'What is the prediction?', 'Why?'], 'function_calls': ['mistake_one(id=45)']}, {'user_input': 'Now show me the ones with past electricity below 5000', 'conversation_history': ['What are the ids?', 'Show sample 450'], 'function_calls': ['show_group(past_electricity_max=5000)']}, {'user_input': 'Is this a typical result?', 'conversation_history': ['Predict 100th sample'], 'function_calls': []}, {'user_input': 'Predict where it is warmer than 30', 'conversation_history': ['Show samples where outdoor is colder than 20'], 'function_calls': ['predict_group(outdoor_temperature_min=30)']}, {'user_input': 'How do you explain stuff and why indoor above 25 are predicted this way', 'conversation_history': ['Tell me about the data', 'Show the first id'], 'function_calls': ['about_explainer()', 'explain_group(indoor_temperature_min=25)']}, {'user_input': "I don't agree", 'conversation_history': ['Is prediction for id 130 correct?'], 'function_calls': []}, {'user_input': 'Show more details', 'conversation_history': ['Tell about data'], 'function_calls': ['about_dataset_in_depth()']}, {'user_input': 'What is the prediction and how to change it?', 'conversation_history': ['Show me the data', 'Show id 38'], 'function_calls': ['predict_one(id=38)', 'cfes_one(id=38)']}]
        
        YOUR RESPONSE SHOULD BE A LIST OF SAMPLE OBJECTS! DO NOT WRAP THE RESULTING LIST IN AN OBJECT.
        
        Generate as many samples as user asks.
        